1:1-1:1::BST.$trModule :: "GHC.Types.Module"
26:1-26:6::BST.empty :: "forall a b . {VV : (BST.BSTree a b) | size VV == 0}"
31:1-31:10::BST.singleton :: "forall a b . a -> b -> {t : (BST.BSTree a b) | size t == 1}"
31:11-31:12::k :: "a"
31:13-31:14::v :: "a"
31:22-31:23::k :: "{VV : a | VV == k}"
31:24-31:25::v :: "{VV : a | VV == v}"
31:26-31:29::_ :: "{VV : forall a b .\n      {v : (BST.BSTree a b) | size v == 0\n                              && height v == 0\n                              && v == Nil} | VV == Nil}"
31:30-31:33::_ :: "{VV : forall a b .\n      {v : (BST.BSTree a b) | size v == 0\n                              && height v == 0\n                              && v == Nil} | VV == Nil}"
36:1-36:5::BST.size :: "forall a b .\nx1:(BST.BSTree a b) -> {VV : GHC.Types.Int | VV == size x1\n                                             && VV >= 0}"
36:23-36:24::lq_anf$##7205759403792806345 :: "{v : GHC.Prim.Int# | v == 0}"
37:23-37:24::lq_anf$##7205759403792806347 :: "GHC.Types.Int"
37:27-37:33::lq_anf$##7205759403792806348 :: "{v : GHC.Types.Int | v == size l\n                     && v >= 0}"
37:32-37:33::l :: "{v : (BST.BSTree a b) | height v >= 0\n                        && 0 <= size v\n                        && 0 <= height v\n                        && v == l}"
37:36-37:42::lq_anf$##7205759403792806350 :: "{v : GHC.Types.Int | v == size r\n                     && v >= 0}"
37:41-37:42::r :: "{v : (BST.BSTree a b) | height v >= 0\n                        && 0 <= size v\n                        && 0 <= height v\n                        && v == r}"
43:1-43:7::BST.height :: "forall a b .\nx1:(BST.BSTree a b) -> {VV : GHC.Types.Int | VV == height x1\n                                             && VV >= 0}"
43:25-43:26::lq_anf$##7205759403792806352 :: "{v : GHC.Prim.Int# | v == 0}"
44:25-44:26::lq_anf$##7205759403792806354 :: "GHC.Types.Int"
44:29-44:54::lq_anf$##7205759403792806357 :: "GHC.Types.Int"
44:33-44:43::lq_anf$##7205759403792806355 :: "{v : GHC.Types.Int | v == height l\n                     && v >= 0}"
44:41-44:42::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
44:44-44:54::lq_anf$##7205759403792806356 :: "{v : GHC.Types.Int | v == height r\n                     && v >= 0}"
44:52-44:53::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
50:1-50:7::BST.insert :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> a -> b -> {t' : (BST.BSTree a b) | size t' == size x2\n                                                          || size t' == size x2 + 1}"
50:12-50:13::k :: "a"
50:14-50:15::v :: "a"
50:19-50:32::BST.singleton :: "{VV : forall a b .\n      x1:a -> x2:b -> {v : (BST.BSTree a b) | size v == 1\n                                              && v == singleton x1 x2\n                                              && v == Node x1 x2 Nil Nil} | VV == singleton}"
50:29-50:30::k :: "{VV : a | VV == k}"
50:31-50:32::v :: "{VV : a | VV == v}"
52:7-52:9::k :: "{VV : a | VV == k}"
52:12-52:13::k :: "{VV : a | VV == k}"
52:20-52:47::BST.Node :: "{VV : forall a b .\n      x1:a -> x2:b -> x3:(BST.BSTree {VV : a | VV < x1} b) -> x4:(BST.BSTree {VV : a | VV > x1} b) -> {v : (BST.BSTree a b) | tright v == x4\n                                                                                                                              && tleft v == x3\n                                                                                                                              && tval v == x2\n                                                                                                                              && tkey v == x1\n                                                                                                                              && size v == (1 + size x3) + size x4\n                                                                                                                              && height v == 1 + (if height x3 > height x4 then height x3 else height x4)\n                                                                                                                              && v == Node x1 x2 x3 x4} | VV == Node}"
52:25-52:26::k :: "{VV : a | VV == k}"
52:27-52:28::v :: "{VV : a | VV == v}"
52:29-52:45::lq_anf$##7205759403792805984 :: "{v' : (BST.BSTree a b) | size v' == size l\n                         || size v' == size l + 1\n                         && v' == insert l k v}"
52:37-52:38::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
52:39-52:41::k :: "{VV : a | VV == k}"
52:42-52:44::v :: "{VV : a | VV == v}"
52:46-52:47::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
53:7-53:9::k :: "{VV : a | VV == k}"
53:12-53:13::k :: "{VV : a | VV == k}"
53:20-53:47::BST.Node :: "{VV : forall a b .\n      x1:a -> x2:b -> x3:(BST.BSTree {VV : a | VV < x1} b) -> x4:(BST.BSTree {VV : a | VV > x1} b) -> {v : (BST.BSTree a b) | tright v == x4\n                                                                                                                              && tleft v == x3\n                                                                                                                              && tval v == x2\n                                                                                                                              && tkey v == x1\n                                                                                                                              && size v == (1 + size x3) + size x4\n                                                                                                                              && height v == 1 + (if height x3 > height x4 then height x3 else height x4)\n                                                                                                                              && v == Node x1 x2 x3 x4} | VV == Node}"
53:25-53:26::k :: "{VV : a | VV == k}"
53:27-53:28::v :: "{VV : a | VV == v}"
53:29-53:30::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
53:31-53:47::lq_anf$##7205759403792805983 :: "{v' : (BST.BSTree a b) | size v' == size r\n                         || size v' == size r + 1\n                         && v' == insert r k v}"
53:39-53:40::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
53:41-53:43::k :: "{VV : a | VV == k}"
53:44-53:46::v :: "{VV : a | VV == v}"
54:20-54:34::BST.Node :: "{VV : forall a b .\n      x1:a -> x2:b -> x3:(BST.BSTree {VV : a | VV < x1} b) -> x4:(BST.BSTree {VV : a | VV > x1} b) -> {v : (BST.BSTree a b) | tright v == x4\n                                                                                                                              && tleft v == x3\n                                                                                                                              && tval v == x2\n                                                                                                                              && tkey v == x1\n                                                                                                                              && size v == (1 + size x3) + size x4\n                                                                                                                              && height v == 1 + (if height x3 > height x4 then height x3 else height x4)\n                                                                                                                              && v == Node x1 x2 x3 x4} | VV == Node}"
54:25-54:27::k :: "{VV : a | VV == k}"
54:28-54:30::v :: "{VV : a | VV == v}"
54:31-54:32::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
54:33-54:34::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
59:1-59:7::BST.lookup :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\n(BST.BSTree a b) -> a -> (Functions_Types.Maybe b)"
59:12-59:13::k :: "a"
59:19-59:26::_ :: "{VV : forall a .\n      {v : (Functions_Types.Maybe a) | (isJust v <=> false)\n                                       && v == Nothing} | VV == Nothing}"
61:7-61:9::k :: "{VV : a | VV == k}"
61:12-61:13::k :: "{VV : a | VV == k}"
61:19-61:30::BST.lookup :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\n(BST.BSTree a b) -> a -> (Functions_Types.Maybe b)"
61:26-61:27::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
61:28-61:30::k :: "{VV : a | VV == k}"
62:7-62:9::k :: "{VV : a | VV == k}"
62:12-62:13::k :: "{VV : a | VV == k}"
62:19-62:30::BST.lookup :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\n(BST.BSTree a b) -> a -> (Functions_Types.Maybe b)"
62:26-62:27::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
62:28-62:30::k :: "{VV : a | VV == k}"
63:19-63:25::Functions_Types.Just :: "{VV : forall a .\n      x1:a -> {v : (Functions_Types.Maybe a) | Just##lqdc##$select v == x1\n                                               && (isJust v <=> true)\n                                               && fromJust v == x1\n                                               && v == Just x1} | VV == Just}"
63:24-63:25::v :: "{VV : a | VV == v}"
69:1-69:14::BST.lem_lookup_eq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:b -> {VV : () | lookup (insert x2 x3 x4) x3 == Just x4}"
69:25-69:27::GHC.Tuple.() :: "{v : () | v == ()}"
71:7-71:10::ds_d3aL :: "a"
71:14-71:15::k :: "{VV : a | VV == k}"
71:25-71:27::GHC.Tuple.() :: "{v : () | v == ()}"
72:7-72:10::ds_d3aL :: "a"
72:14-72:15::k :: "{VV : a | VV == k}"
72:25-72:48::BST.lem_lookup_eq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:b -> {VV : () | lookup (insert x2 x3 x4) x3 == Just x4}"
72:39-72:40::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
72:41-72:44::ds_d3aL :: "a"
72:45-72:48::ds_d3aM :: "a"
73:25-73:48::BST.lem_lookup_eq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:b -> {VV : () | lookup (insert x2 x3 x4) x3 == Just x4}"
73:39-73:40::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
73:41-73:44::ds_d3aL :: "a"
73:45-73:48::ds_d3aM :: "a"
79:1-79:15::BST.lem_lookup_neq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:{VV : a | VV /= x3} -> x5:b -> {VV : () | lookup (insert x2 x4 x5) x3 == lookup x2 x3}"
79:20-79:22::k1 :: "a"
79:23-79:25::k2 :: "{VV : a | VV /= k1}"
80:7-80:9::k1 :: "{VV : a | VV == k1}"
80:12-80:14::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
80:29-80:31::GHC.Tuple.() :: "{v : () | v == ()}"
81:29-81:31::GHC.Tuple.() :: "{v : () | v == ()}"
83:7-83:9::k1 :: "{VV : a | VV == k1}"
83:13-83:14::k :: "{VV : a | VV == k}"
83:16-83:17::k :: "{VV : a | VV == k}"
83:21-83:23::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
83:29-83:31::GHC.Tuple.() :: "{v : () | v == ()}"
84:7-84:8::k :: "{VV : a | VV == k}"
84:13-84:15::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
84:29-84:31::GHC.Tuple.() :: "{v : () | v == ()}"
85:7-85:9::k1 :: "{VV : a | VV == k1}"
85:13-85:14::k :: "{VV : a | VV == k}"
85:16-85:17::k :: "{VV : a | VV == k}"
85:21-85:23::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
85:29-85:31::GHC.Tuple.() :: "{v : () | v == ()}"
86:7-86:9::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
86:13-86:14::k :: "{VV : a | VV == k}"
86:16-86:17::k :: "{VV : a | VV == k}"
86:21-86:23::k1 :: "{VV : a | VV == k1}"
86:29-86:31::GHC.Tuple.() :: "{v : () | v == ()}"
87:7-87:9::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
87:13-87:14::k :: "{VV : a | VV == k}"
87:16-87:17::k :: "{VV : a | VV == k}"
87:21-87:23::k1 :: "{VV : a | VV == k1}"
87:29-87:31::GHC.Tuple.() :: "{v : () | v == ()}"
88:7-88:9::k1 :: "{VV : a | VV == k1}"
88:12-88:13::k :: "{VV : a | VV == k}"
88:15-88:17::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
88:20-88:21::k :: "{VV : a | VV == k}"
88:29-88:54::BST.lem_lookup_neq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:{VV : a | VV /= x3} -> x5:b -> {VV : () | lookup (insert x2 x4 x5) x3 == lookup x2 x3}"
88:44-88:45::l :: "{v : (BST.BSTree {VV : a | VV < k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == l}"
88:46-88:48::k1 :: "{VV : a | VV == k1}"
88:49-88:51::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
88:52-88:54::ds_d2UV :: "a"
89:7-89:8::k :: "{VV : a | VV == k}"
89:11-89:13::k1 :: "{VV : a | VV == k1}"
89:15-89:16::k :: "{VV : a | VV == k}"
89:19-89:21::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
89:29-89:54::BST.lem_lookup_neq :: "forall a b .\n(GHC.Classes.Ord<[]> a) =>\nx2:(BST.BSTree a b) -> x3:a -> x4:{VV : a | VV /= x3} -> x5:b -> {VV : () | lookup (insert x2 x4 x5) x3 == lookup x2 x3}"
89:44-89:45::r :: "{v : (BST.BSTree {VV : a | VV > k} b) | height v >= 0\n                                        && size v >= 0\n                                        && 0 <= size v\n                                        && 0 <= height v\n                                        && v == r}"
89:46-89:48::k1 :: "{VV : a | VV == k1}"
89:49-89:51::k2 :: "{VV : a | VV /= k1\n          && VV == k2}"
89:52-89:54::ds_d2UV :: "a"
97:1-97:7::BST.exTree :: "x1:() -> {VV : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | VV == exTree x1\n                                                             && VV == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"}"
97:19-97:58::lq_anf$##7205759403792806401 :: "(BST.BSTree GHC.Types.Int [GHC.Types.Char])"
97:27-97:48::lq_anf$##7205759403792806396 :: "(BST.BSTree GHC.Types.Int [GHC.Types.Char])"
97:35-97:38::_ :: "{VV : forall a b .\n      {v : (BST.BSTree a b) | size v == 0\n                              && height v == 0\n                              && v == Nil} | VV == Nil}"
97:39-97:41::lq_anf$##7205759403792806393 :: "GHC.Types.Int"
97:42-97:47::lq_anf$##7205759403792806395 :: "[GHC.Types.Char]"
97:49-97:51::lq_anf$##7205759403792806398 :: "GHC.Types.Int"
97:52-97:57::lq_anf$##7205759403792806400 :: "[GHC.Types.Char]"
97:59-97:61::lq_anf$##7205759403792806403 :: "GHC.Types.Int"
97:62-97:69::lq_anf$##7205759403792806405 :: "[GHC.Types.Char]"
101:1-101:7::BST.propOK :: "() -> {VV : GHC.Types.Bool | VV}"
101:13-101:25::lq_anf$##7205759403792806409 :: "(Functions_Types.Maybe [GHC.Types.Char])"
101:20-101:22::ex :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"\n                                                   && height v >= 0\n                                                   && size v >= 0\n                                                   && 0 <= size v\n                                                   && 0 <= height v\n                                                   && v == ex}"
101:23-101:25::lq_anf$##7205759403792806408 :: "GHC.Types.Int"
101:29-101:39::lq_anf$##7205759403792806412 :: "{v : (Functions_Types.Maybe [GHC.Types.Char]) | isJust v <=> true}"
101:34-101:39::lq_anf$##7205759403792806411 :: "[GHC.Types.Char]"
102:13-102:25::lq_anf$##7205759403792806416 :: "(Functions_Types.Maybe [GHC.Types.Char])"
102:20-102:22::ex :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"\n                                                   && height v >= 0\n                                                   && size v >= 0\n                                                   && 0 <= size v\n                                                   && 0 <= height v\n                                                   && v == ex}"
102:23-102:25::lq_anf$##7205759403792806415 :: "GHC.Types.Int"
102:29-102:39::lq_anf$##7205759403792806419 :: "{v : (Functions_Types.Maybe [GHC.Types.Char]) | isJust v <=> true}"
102:34-102:39::lq_anf$##7205759403792806418 :: "[GHC.Types.Char]"
103:13-103:25::lq_anf$##7205759403792806423 :: "(Functions_Types.Maybe [GHC.Types.Char])"
103:20-103:22::ex :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"\n                                                   && height v >= 0\n                                                   && size v >= 0\n                                                   && 0 <= size v\n                                                   && 0 <= height v\n                                                   && v == ex}"
103:23-103:25::lq_anf$##7205759403792806422 :: "GHC.Types.Int"
103:29-103:41::lq_anf$##7205759403792806426 :: "{v : (Functions_Types.Maybe [GHC.Types.Char]) | isJust v <=> true}"
103:34-103:41::lq_anf$##7205759403792806425 :: "[GHC.Types.Char]"
104:13-104:24::lq_anf$##7205759403792806430 :: "(Functions_Types.Maybe [GHC.Types.Char])"
104:20-104:22::ex :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"\n                                                   && height v >= 0\n                                                   && size v >= 0\n                                                   && 0 <= size v\n                                                   && 0 <= height v\n                                                   && v == ex}"
104:23-104:24::lq_anf$##7205759403792806429 :: "GHC.Types.Int"
104:29-104:36::_ :: "{VV : forall a .\n      {v : (Functions_Types.Maybe a) | (isJust v <=> false)\n                                       && v == Nothing} | VV == Nothing}"
106:5-106:7::ex :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"}"
106:13-106:22::_ :: "{v : (BST.BSTree GHC.Types.Int [GHC.Types.Char]) | v == exTree ()\n                                                   && v == insert (insert (insert Nil 10 \"cat\") 20 \"dog\") 30 \"zebra\"}"
106:20-106:22::GHC.Tuple.() :: "{v : () | v == ()}"